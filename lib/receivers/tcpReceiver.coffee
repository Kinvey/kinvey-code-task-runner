# Copyright (c) 2016 Kinvey Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
# in compliance with the License. You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software distributed under the License
# is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
# or implied. See the License for the specific language governing permissions and limitations under
# the License.

net = require 'net'
config = require 'config'
log = require '../log/logger'
server = {}

composeErrorReply = (errorMessage, debugMessage, err, metadata) ->
  # build an error response as generated by blApi
  # FIXME: error response format should be handled by the outermost layer,
  # and not be duplicated in various places
  return ret =
    isError: true
    statusCode: 550
    error: err.toString()
    message: errorMessage
    debugMessage: debugMessage
    # note: stack is not a stack array, its a formatted text string that contains a printed stack trace
    stackTrace: err.stack
    metadata: metadata ? {}

parseTask = (task, callback) ->
  log.DEBUG "parseTask Invoked"
  log.DEBUG task
  unless task?
    return composeErrorReply 'Internal Error', 'Bad Request', new Error('Bad Request'), {}
  if typeof task is 'object'
    return callback null, task

  try
    parsedTask = JSON.parse task
  catch e
    return callback new Error 'invalid task: unable to parse task json'

  callback null, parsedTask

exports.startServer = (taskReceivedCallback, startedCallback) ->

  data = ''
  line = ''

  server = net.createServer (socket) ->
    log.INFO "Connection established"
    data = ""
    line = ""

    socket.on 'data', (chunk) ->
      log.DEBUG "chunk received"
      # always append the new data, then process task below
      data += chunk.toString()

      # process one task at a time in arrival order, sending back responses in the same order
      # an already running processing loop will handle the newly arrived task as well

      while true
        lineEnd = data.indexOf('\n')
        if (lineEnd < 0)
           # stop processing when no (no more) complete lines await
          return
        task = data.slice(0, lineEnd+1)
        data = data.slice(lineEnd + 1)
        # TODO: do not ^^^ re-copy all the data for each task line, index into data instead
        # skip blank lines, processBL non-blank ones
        if (task) then break
      if (task.indexOf '{"healthCheck":1}') > -1
        log.INFO "healthcheck!"
        healthStatus = JSON.stringify {"status":"ready"}
        socket.write "#{healthStatus}\n"
        return
      else
        log.DEBUG 'About to parse task'
        log.DEBUG "Task: #{task}"
        parseTask task, (parseError, parsedTask) ->
          log.DEBUG "Task parsing complete"
          if parseError?
            log.ERROR "Parse error! #{parseError}"
            parseError.isError = true
            socket.write JSON.stringify composeErrorReply 'Internal Error', parseError.toString(), parseError
            socket.write '\n'
            return
          log.DEBUG "About to invoke taskReceivedCallback"
          log.DEBUG parsedTask
          taskReceivedCallback parsedTask, (err, result) ->
            log.DEBUG "About to respond"
            # processBL returns a pre-assembled response object
            if err?
              log.DEBUG "Responding with error"
              log.ERROR err
              socket.write JSON.stringify composeErrorReply('Internal Error', 'Unable to run dlc script', err)
              socket.write '\n'
              return
            else
              log.DEBUG "Responding with success"
              log.DEBUG result
              # make sure result is present, undefined is not stringified into the json
              if result is undefined then result = null

              # TODO: check size of ret and use a non-blocking serializer if too large
              socket.write JSON.stringify result
              socket.write '\n'


    socket.on 'connect', () ->
    #console.log { containerId: dockerHost, message: "Socket connected"}

    socket.on 'end', () ->
    #console.log { containerId: dockerHost, message: "Socket ended"}

    socket.on 'error', (err) ->
    #console.log { containerId: dockerHost, message: "Socket Error", error: err.toString(), stack: err.stack}


    socket.on 'close', (hasError) ->
      status = if hasError is true then 'error' else 'success'
    #console.log { containerId: dockerHost, message: "Socket closed with #{status}"}


  server.on 'close', () ->
  #console.log { containerId: dockerHost, message: "Server connection closed"}

  server.on 'error', (err) ->
  #console.log { containerId: dockerHost, message: "Server Error", error: err.toString(), stack: err.stack}

  process.nextTick () ->
    server.listen config.server?.port or 7000, () ->
      startedCallback()

exports.stop = () ->
  server.close()